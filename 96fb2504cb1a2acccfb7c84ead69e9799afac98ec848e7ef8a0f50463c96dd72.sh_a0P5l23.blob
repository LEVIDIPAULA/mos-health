using System;
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using BepInEx;
using BepInEx.Logging;
using HarmonyLib;

[assembly: BepInPlugin("Matsuura.HealthMetrics", "HealthMetrics", "1.0.0")]

namespace HealthMetrics
{
    [BepInPlugin("Matsuura.HealthMetrics", "HealthMetrics", "1.0.0")]
    public class HealthMetricsBase : BaseUnityPlugin
    {
        private readonly Harmony _harmony = new Harmony("Matsuura.HealthMetrics");

        private static HealthMetricsBase _instance;
        private static ManualLogSource _logSource;

        internal void Awake()
        {
            if (_instance == null)
            {
                _instance = this;
            }
            if (_logSource == null)
            {
                _logSource = Logger.CreateLogSource("Matsuura.HealthMetrics");
            }
            _harmony.PatchAll();
            _logSource.LogInfo("HealthMetrics Awake");
        }

        internal static void Log(string message)
        {
            if (_logSource != null)
            {
                _logSource.LogInfo(message);
            }
        }

        internal static void LogD(string message)
        {
            if (_logSource != null)
            {
                _logSource.LogDebug(message);
            }
        }
    }

    [HarmonyPatch(typeof(HUDManager))]
    internal class HealthHUDPatches
    {
        private static TextMeshProUGUI _healthText;
        private static readonly string DefaultValueHealthText = " Â¤";
        private static int _oldValuehealthValueForUpdater = 0;
        private static int _healthValueForUpdater = 100;
        private static readonly Color _healthyColor = Color.green;
        private static readonly Color _criticalHealthColor = Color.red;

        [HarmonyPatch("Start")]
        [HarmonyPostfix]
        private static void Start(ref HUDManager __instance)
        {
            GameObject healthDisplay = new GameObject("HealthHUDDisplay");
            healthDisplay.AddComponent<RectTransform>();
            TextMeshProUGUI healthText = healthDisplay.AddComponent<TextMeshProUGUI>();
            RectTransform rectTransform = healthText.rectTransform;
            rectTransform.SetParent(__instance.PTTIcon.transform, false);
            rectTransform.anchoredPosition = new Vector2(8f, -57f);
            healthText.font = __instance.controlTipLines[0].font;
            healthText.fontSize = 16f;
            healthText.text = "100%";
            healthText.color = _healthyColor;
            healthText.overflowMode = TextOverflowModes.Overflow;
            healthText.enabled = true;
            _healthText = healthText;
        }

        [HarmonyPatch("Update")]
        [HarmonyPostfix]
        private static void Update()
        {
            if (_healthText != null && _healthValueForUpdater != _oldValuehealthValueForUpdater)
            {
                _oldValuehealthValueForUpdater = _healthValueForUpdater;
                int displayedValue = Mathf.Clamp(_healthValueForUpdater, 0, 100);
                _healthText.text = $"{displayedValue}%";
                float percentage = displayedValue / 100f;
                _healthText.color = ColorInterpolation(_criticalHealthColor, _healthyColor, percentage);
            }
        }

        private static Color ColorInterpolation(Color start, Color end, float percentage)
        {
            return Color.Lerp(start, end, percentage);
        }
    }

    [HarmonyPatch(typeof(PlayerControllerB))]
    internal class PlayerPatches
    {
        [HarmonyPrefix]
        [HarmonyPatch("LateUpdate")]
        private static void LateUpdate_Prefix(PlayerControllerB __instance)
        {
            if ((__instance as NetworkBehaviour).IsOwner && ((!(__instance as NetworkBehaviour).IsServer) || __instance.isHostPlayerObject))
            {
                HealthHUDPatches._healthValueForUpdater = Mathf.Max(__instance.health, 0);
            }
        }
    }
}
